# 路由算法
**最佳路由：“最佳”只能是相对于某一特定要求下得出的较为合理的选择而已**

## 分层次的路由选择协议
为什么要进行分层次呢？

因为：

+ 整个网络世界的规模非常庞大，不可能让一个路由器知道每个 ip 地址
+ 一些单位不想让外部知道自己的路由选择协议，但还想连入因特网

整个网络可以被分为一个一个的自治系统（AS），路由算法可以被分为 AS 内的和 AS 之间的。

首先我们需要知道什么是自治系统：

在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由（就是有一组路由器在 AS 内），同时还使用一种 AS 之间的路由协议以确定在 AS 之间的路由（在 AS 之间的路由器）。

在一个 AS 内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内部都必须连通。

![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/48073730/1739880594590-02f1c064-3603-4dc3-ace0-3de7520d411d.jpeg)



## 静态路由算法（非自适应路由算法）
需要管理员手工配置路由信息

其简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络中。缺点就是路由更新慢，不适用与大型网络。

## 动态路由算法（自适应路由算法）
让路由器之间彼此交换信息，按照路由算法优化出路由表项

其更新快，使用于大型网络，及时响应网路拓扑变化。缺点是算法复杂，增加网络负担。

### 全局性（知道全局路由状态）
典型代表就是 OSPF（链路状态路由算法）

所有路由器掌握完整的网络拓扑和链路费用信息（<font style="color:rgb(51, 51, 51);">是指用于评估网络中各个链路（或连接）质量的数值。这些费用信息帮助路由协议决定数据包在网络中传输的最佳路径</font>）

### 分散性（只知道自己附近的路由状态）
# RIP 协议与距离向量算法
典型代表就是 RIP（距离向量路由算法：这个名字的由来：距离是指离目的路由的跳数，向量指的是一条数据由多个数据项构成）

RIP 是一种分布式的基于距离向量的路由器选择协议，是因特网的协议标准，最大优点是简单。
RIP 协议要求网络中的每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录。

距离：就是跳数，从源端口到目的端口所经历的路由器的个数（包括端口处的路由器），经过一个路由器，跳数就+1。RIP 允许一条路由器最多包含 15 个路由器，因此距离为 16 表示该网络不可达。基于它的跳数限制其只适用于小型网络。

我们需要知道的是在一个自治系统中使用 RIP 协议，怎样让每个路由器知道该 AS 中的 IP 信息呢。

那么它是采用的：

+ 仅和相邻的路由器交换信息
+ 路由器交换的信息是自己的路由表
+ 每 30 秒进行一次更新，然后路由器根据更新后的信息再次更新自己的信息。如果超过 180 秒没有收到相邻路由器的信息就会认为邻居没有了，此时会将自己路由表上关于没有的路由器的距离设置为 16，表示不可达。

## 怎样更新路由表的呢？
相邻两个路由器之间交换各自的路由信息是通过 RIP 报文进行交换的。

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1739964901075-9203647f-1c93-443b-a96b-3debc55a988d.png)

进行更新的步骤：

+ 1、 修改相邻路由器发来的 RIP 报文中所有表项；因为是相邻的，其距离就不可能相同，还有下一跳也不同，所以需要修改所有的表项。怎样修改呢？假设有个路由器其地址为 X，有个 R1 路由器挨着地址为 X 的路由器，X 发送 RIP 报文，R1 接受到后需要将所有表项的“距离”字段+1，下一跳的地址修改为 X
+ 2、 对 RIP 修改后需要将该 RIP 报文中的数据进行更新到路由器中。此时需要进行下列步骤：

子步骤：

1. 若 R1 路由器中没有 Net3，则直接将 RIP 报文中的项目填入 R1 路由器
2. 若 R1 路由器中有 Net3，那么就需要查看路由器中下一跳的地址。若路由器中下一跳的地址为 X 那么就直接更新（因为需要保持实时状态撒）；若路由器中下一跳不是 X 则需要比较两者之间的距离了，将路由器中的表项更新为距离短的
+ 3、若 180s 后还没有收到相邻路由器 X 的更新路由表，则 R1 将 X 记为不可达的路由器（将距离设置为 16）

## RIP 协议的报文格式
![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1739965727793-e3982b14-e163-40cd-a60c-b73851e36035.png)

需要注意的是：

RIP 协议是在应用层的

每个 RIP 协议中最多只能包含 25 个路由，如果超过的话就必须再发送一个 RIP 报文



RIP 对于“坏”消息传递的较慢。举个例子：

![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/48073730/1739966194917-709304d4-d0cb-4cea-a128-d08ddede2d69.jpeg)

路由器 R1 左侧的路由器损坏了，R1 在 180s 内没有收到左侧路由发送的 RIP 报文，所以将对应的表项的距离设置为 16 了，但是还没有到 30s，R1 没有通知 R2，但是此时 R2 恰好到了更新的时候并且在 R2 中存在通向已经损坏的路由器的转发表项，给了 R1 后，R1 就会进行更新存储，然后 R1 又给 R2，往互循环直到“距离”加到 16 才可以直到损坏的路由器不能到达。

# OSPF 协议与链路状态算法
这个协议叫做：开放最短路径优先协议：“开放”标明 OSPF 协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法 SPF

OSPF 最主要的特征就是使用分布式的链路状态协议

OSPF 的特点：

+ 使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，然后每个相邻路由器又再次将此信息发往其所有的相邻路由器。（类似于广播）
+ 发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量/代价-费用、距离、时延、带宽等）
+ 只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息

通过上述的过程最终所有的路由器都能建立一个链路状态数据库，即全网拓扑图。

## OSPF 算法
通过上面的操作可以让每个路由器得到整体的信息，而且只要有一个路由器链路发生变化就会从点到面的进行更新。

## OSPF 的分区
为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。

每一个区域都有一个 32 位的区域标识符（用点分十进制表示），区域也不能太大，在一个区域内的路由器最好不超过 200 个。

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1739968195975-c8d06c81-abd4-45d0-9590-a293d07950f2.png)

## OSPF 的数据分组
![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1739968491843-1817ad42-1ed7-4406-8ea9-6bdeff9a0e4e.png)

考纲说 OSPF 是网络层的协议，但有些人又说因为将 OSPF 数据放入 IP 数据分组中，所以说其是网络层协议。

因为我们是考研所以还是以考纲为准，认为其是网络层协议。

## OSPF 的其他特点
1. 每隔 30 分钟需要进行刷新一次
2. 由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系，因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多
3. OSPF 不存在坏消息传的慢的问题，它的收敛速度很快

