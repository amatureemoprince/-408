# TCP 的特点
1. TCP 是面向连接（虚连接）的传输层协议
2. 每一条 TCP 连接只能有两个端点，意思就是说 TCP 只能是点对点的
3. TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达。可靠有序，不丢不重
4. TCP 提供全双工通信。在发送、接收端分别设置有缓存
5. TCP 面向字节流。TCP 把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

发送文件的大致流程：每次携带一串字节

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740188513249-a946a17c-3f01-4720-a98d-d27929d324cf.png)

# TCP 报文段首部格式
![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740188636321-4c02b8d8-dd19-478d-9468-1e11e19c1d4e.png)

TCP 首部存在 20B 固定长。目的端口和源端口就不再说了。
**序号（seq）**：在一个 TCP 连接中传送的字节流中的每个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。如上面发送一个 TCP 头和 1、2、3 字节，首部对应的序号就是第一个 1。

**确认号（ack）**：期望收到下一个报文段的第一个数据字节的序号。若确认号为 N，则证明到序号 N-1 为止的所有数据都已经正确收到了。如上面第一个 TCP 已经带着 1、2、3 字节了，希望跟着他的下一个字节是 4，所以对应的确认号字段为 4.

**数据偏移（首部长度）**：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，以 4B 为单位的，就是最后的结果需要乘以 4 才是真实的结果。如上面一个 TCP 报文段的数据偏移字段为 15，则真实的长度为 60B，所以除了固定长度 20B 外，还有选项字段加填充字段 40B。

**URG**：这个是一个紧急位，表示该报文段有紧急数据需要传送，不需要在发送缓存中排队，配置紧急指针字段使用。

**ACK**：确认位，ACK=1 时确认号有效，在连接建立后所有传送的报文段都必须把 ACK 置为 1.

**PSH**：推送位，和 URG 有点类似，但是是在接收方的，该字段为 1 的话，接收方需要尽快将该报文段交付给应用程序，不需要在接收缓存中排队。

**RST**：复位位， RST 为 1 时，表示 TCP 连接中出现严重差错，必须释放连接，然后重新建立传输连接。

**SYN**：同步位，SYN 为 1 时，表示一个连接请求或者接收报文，在建立连接需要使用。

**FIN**：终止位，FIN 为 1 时，表示此报文发送方的数据已经发送完毕了，要求释放连接。

**窗口**：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。告诉对方下次你可以给我发送多少数据量。

**检验和**：和 UDP 一样需要检验首部+数据部分。检验时要加上 12B 的伪首部，伪首部中的类型字段使用 6 来表示 TCP 协议。

**紧急指针**：URG 为 1 时才有意义，所以说 URG 要配置紧急指针使用，指出本报文段中的紧急数据的字节数。

**选项**：最大报文段长度 MSS（用于传输层规定的最大长度）、窗口扩大，时间错等等。

**填充**：让 TCP 首部字节数为 4B 整数倍，需要的话就填充 0 字节。

# TCP 的连接管理
这个的存在是为了运输连接的建立和释放都能正常进行。

## TCP 连接传输的三个过程（三次握手）
1. 建立连接
2. 传输数据
3. 释放连接

TCP 连接的建立是采用的“客户服务器”的方式进行的，主动发起连接的主机称为客户，被动接收请求的主机称为服务器。

建立连接的示意图：

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740192726790-7040ae61-51d0-4353-8b44-48de6b9a00b4.png)
过程：写最为重要的部分。需要注意的是 SYN=1 的报文是不能携带数据的。

+ 客户需要发起一个请求连接的报文段，此报文的 SYN=1，并随机生成一个序号 seq=x。
+ 服务器接收到后，如果同意连接就返回一个报文段，该报文段的 SYN=ACK=1，也随机生成一个序号 seq=y，并且返回确认号 ack=x+1（表明我下一个接收的序号为 x+1）
+ 到达客户后，客户再发送一个 SYN=0，ACK=1，seq=x+1，ack=y+1 的报文段给服务器。此时这个报
+ 文段是带着数据的，如果不带数据 seq 就仍为 x（不消耗序号），下一个报文段再设置为 x+1

## SYN 泛洪攻击
该攻击发生在 OSI 层的第四层（传输层），这种方式利用 TCP 协议的特性，也就是三次握手，攻击者发送大量的三次握手中的第一次请求报文段，而当服务器返回一个 ACK 报文段后就不再发送确认报文段，这样这些 TCP 连接就会处于挂起状态，服务器收不到确认的话，就会重复发送 ACK 给攻击者。这样就会浪费服务器的资源，这些大量的处于挂起状态的 TCP 连接会消耗服务器的 CPU 和内存，最后服务器可能死机，就无法为正常用户提供服务了。

## TCP 连接释放的过程（四次挥手）
在参与 TCP 连接的两个进程，其中任意一个进行都能终止该连接。

这个关闭可以想象为一条 TCP 连接的两条数据链路都需要关闭。（TCP 全双工嘛）

每关闭一条都需要请求和确认两次发送。

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740212488999-526e7f16-c2a7-4f06-b56b-6aba8c449ef3.png)

+ 客户端需要关闭连接，会发送一个 FIN 为 1，seq 为 u（u 为上一个报文的最后一个字节序号+1） 的报文段，并停止发送数据。此时客户端就处于 FIN-WAIT-1 状态。此时客户端就已经不能再主动发送数据了，但是服务器还可以发送数据。
+ 服务器会接收到客户端发送过来的 FIN=1 的报文，此时服务器会返回一个 ACK=1 ，ack=u+1，seq=v 的报文段（因为之前的客户端报文 seq=u，所以服务器需要下一个报文的开头为 u+1。v 是服务器最后一个报文段中最后一个字节序号+1）。发送后服务器进入 CLOSE-WAIT 状态。到这里，客户端到服务器的连接就释放了，但是服务器到客户端的连接还没有关闭。因为至始至终都只是客户端的“要求”罢了。
+ 如果服务器没有再需要发送的数据了，就可以向客户端发送释放报文了，该报文的 FIN、ACK 都为 1，序号 seq=w（服务器可能还发送了一些数据），还得重复发送 ack=u+1。发送后服务器处于 LAST-ACK 状态。
+ 客户端收到了服务器发送的释放报文段，会被动的返回一个确认报文段。该报文段的 ACK=1，seq=u+1，ack=w+1。服务器收到该确认报文后就处于 CLOSED 状态了，客户端还要在 TIME-WAIT 状态，直到时间等待计时器设置的 2MSL（最长报文段寿命）结束，才进入 CLOSED 状态。



# TCP 的可靠传输
可靠传输就是要保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样。

## TCP 实现可靠传输的机制
1. 校验
2. 序号
3. 确认
4. 重传

**校验**和 UDP 协议的校验是一样的，使用伪首部进行辅助计算

**序号**就是对发送的字节进行编号 0、1、2...等等

**确认**采用的是累加确认，接收方返回自己没有收到的序号的确认号，比如，接收方收到了 0~2, 5~8 字节的数据，显然还没有收到 3~7 的数据，此时返回报文段的确认号为 3

**重传**有超时重传和 ACK 冗余重传。超时的意思就是发送方长时间没有收到 ACK，从而进行重传，但是这样的话有个弊端就是等待时间会比较长，所以使用冗余重传来解决这个问题。举个例子：发送方有 0 1 2 3 4 5 6 7 8 9 10 需要发送的字节序号，接收方收到 0 1 2 后返回确认报文段的 ack 为 3，发送方发送 3 4 5 但是因为一些原因丢失了，接着发送 6 7 8，9 10，接收方在接收后两个 TCP 报文段后都会返回一个 ack 为 3 的报文段，这就冗余了，发送方就会知道原来 ack 为 3 的 TCP 报文段发送失败了，就会进行重传。

# TCP的流量控制
流量控制就是控制发送方的速率不至于太快，要让接收方来得及接收

TCP 协议使用滑动窗口机制实现流量控制

在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收方窗口 rwnd（接收方通过设置确认报文段中的窗口字段来实现），发送方的发送窗口取接收窗口 rwnd 和拥塞窗口 rwnd 的最小值。

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740225694572-f7f8a93c-f951-4c5f-8f10-bab703a2fe49.png)

这幅图形象的展示了 TCP 的“累积确认”

在最后的时候，B 返回的确认字段 rwnd 为 0，这表示 B 中的接收窗口已经没有空余的了。

这种情况需要 B 将接收窗口中的数据提交给上层然后 B 向 A 发送一个新的窗口值为止。

TCP 在这里有个探测机制：TCP 会为每个连接设置一个持续计时器，只要发送方收到一个零窗口通知，就会启动该持续计时器，到时间了就给接收方发送一个探测报文段，接收方就会返回一个包含自己接收窗口大小的确认报文段，如果还是为 0 就重置持续计时器，否则就可以继续传输数据了。

# TCP 的拥塞控制
首先我们来想一想出现拥塞的情况是什么，显然就是资源不够用了。（所需的资源>资源总和）

网络中资源出现供应不足时会导致网络性能变差，网络的吞吐量也会随着负荷的增加而下降。

拥塞控制就是防止过多的数据注入到网络中去，是一个全局性的问题。虽然和流量控制都是控制数据的传输，但是两者的作用范围是不同的。

## 拥塞控制的四种算法
因为发送端需要动态的变化自己发送的数据以避免网络发生拥塞，所以发送方需要维护一个拥塞窗口 cwnd

怎样控制的呢？只要网络没有出现拥塞则拥塞窗口就可以变的更大些，一旦网络发生拥塞则就将拥塞窗口变小些。

原理的就是这么一个原理。



因为发送方的发送窗口大小是需要取 min{接收窗口，拥塞窗口}的，其中的接收窗口可以让接收方发送 TCP 报文段来知道，所以发送方就需要维护 cwnd，就会使用慢开始和拥塞避免算法来维护。

### 慢开始和拥塞避免
在研究慢开始和拥塞避免算法时，为了便于理解，我们假设：
数据是单方向传送，对方只传送确认报文

接收方总是有足够大的缓存空间，因此发送方窗口的大小由网络的拥塞程度控制

采用最大报文长度 MSS （最大报文段长度）作为拥塞窗口大小的单位

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740271491341-0473b6b4-1cf2-485c-997b-4b1f9c5621f1.png)

---

> 过程：刚开始使用慢开始算法，就是首先令 cwnd=1， 发送一个报文段进行探测，如果成功接收到接收方返回的确认报文，则将 cwnd 乘以 2，接收方成功返回两个确认报文后，由将 cwnd 乘以 2，这样的增长速率会很快，所以我们需要设置一个慢开始门限 ssthresh，在 cwnd=ssthresh 时就采用拥塞避免算法进行处理，每次接收方成功返回一个确认报文后不是将 cwnd 乘以 2 了，而是进行加 1，知道遇到网络拥塞，就将 ssthresh 重新设置为原来的二分之一，然后重新开始，cwnd=1，巴拉巴拉。
>

需要注意的是：在 cwnd 增加后如果超过了 ssthresh，则将 cwnd 设置为 ssthresh 的大小，就如上面图片的第二次增长，8 后面应该是 16，但是由于 ssthresh 是 12 所以下一次的 cwnd 设置的是 12，而且 ssthresh 要大于等于 2 才行。

### 快重传和快恢复
在数据传输过程中可以某个报文段会丢失，发送方由于迟迟收不到确认报文，会错误的认为发生了网络拥塞，从而减少自己的 cwnd 和重新开始慢开始算法，导致利用率下降，使用快重传算法可以让发送方尽快的知道发生了报文段的丢失，从而减少“误导”时间。

![](https://cdn.nlark.com/yuque/0/2025/png/48073730/1740275163177-c2f46883-2fd0-48b0-b4de-a1d3bc395a70.png)

> 快重传要要求接收方不能在自己发送数据时捎带确认，而要立即发送确认，因为 TCP 采用累积确认，如果发送方发送 1 2 3 报文段，且 2 丢失，那么接收方会一直重复确认 2 号报文段，这样发送方就会收到多个重复的报文段，当为连续 3 个时，就要立即重传丢失的报文段。快恢复算法就是如果发送方接受到 3 个连续的报文段时，就将 ssthresh 设置为此时的 cwnd 的一半并且将 cwnd 也设为此时 cwnd 的一半，然后线性增加。
>

这样做主要是因为害怕网络拥塞，但是因为可以收到连续的报文段可能并不是那么拥塞，就直接从一半开始增加吧，就不从 1 开始了。





