# 浏览器中输入网址后到点击回车后其中发生的事情

首先浏览器做的事情就是解析这个url网址，采用的协议名称、服务器名称、端口号、访问资源在主机的具体位置 （可以为空，
这样服务器会默认index.html或default.html）。解析后会生成请求消息，包括请求方法（Get、Post等）、ip、
版本和携带的数据，但是url里放入的是域名，所以需要DNS的帮助，这个可以根据 域名去查询对应的ip地址，具体的实现方法也十分
的简单：先查看浏览器自己有没有这个url的缓存，没有的话就去问OS有没有，还没有的话还要再去host文件里看 看有没有缓存。
这样的设计可以让我们避免每次访问url都去询问DNS服务器，提高 效率。那如果上述的地方都没有域名对应的ip怎么办呢，这就需要
DNS服务器了，用户的Socket库中的方法向电脑中配置的DNS服务器发送请求：问DNS服务器有没 有这个域名的ip，有的话就直接返回给
你的电脑了，没有的话就要向根DNS服务器 （. 就是这个，一个小点点），根DNS服务器会告诉你去哪里问可以得到结果，就是顶级DNS
服务器，于是你的电脑又发个请求给顶级DNS服务器，然后顶级服务器 又会告诉你到对应的权威DNS服务器中去找，于是你的电脑又发送
一个请求到权威DNS服务器，这下终于找到了，权威DNS服务器告诉你域名对应的ip。

# 协议栈
这下准备工作终于做完了。然后浏览器就会委托OS发送数据，调用Socket库去使用协议栈进行数据的处理 和发送。协议栈有两部分：
上部分是接受浏览器传过来的数据（TCP、UDP），下部分是进行数据的发送（IP）。经过协议栈后让网卡驱动程序加上mac帧就可以通过
网卡发送到以太网中了。在数据的发送（IP）中有两个协议：ARP协议和ICMP协议，前者已经说过了，后者是告知数据包在传输过程中的
错误和控制信息的。

# TCP协议
HTTP是基于TCP协议的协议，那我们先来看看TCP是怎么回事吧。不外乎就是在要发送的数据前面加上了TCP头，那这个头里具体有什么呢？
首先是源端口号和目标端口号，需要知道是那两个应用要进行数据交互吧。还有序号，这个是防止包乱序的情况发生，还有确认号，这是判
断数据包是不是被接受了的，没有正确地接受就可以进行重传，防止了包丢失的问题，还有一些状态位如SYN、ACK、RST、FIN，TCP是面
向连接的，发送的状态位发生变化会导致连接状态发生变化。还有个重要的概念就是滑动窗口，控制流量的，不要在一段时间内发送的数据
太多了，也不要太少了。还可以进行拥塞控制。在使用HTTP发送数据前会先进行TCP的三次握手，确保双方都能进行正确的数据传输。
**具体的过程是：**
开始的时候服务器端和客户端都是处理关闭（close）状态的，然后需要服务器监听一个端口等待着客户端（此时服务器处于listen状态）
在服务器监听的时候客户端发起连接请求SYN就处于SYN_SEND状态了，服务器收到这个请求后，就向客户端发送一个SYN包和一个ACK包
此时服务器处于SYN_RECV状态，前者用于确认连接，后者用于确认服务器收到请求。然后客户端收到这个包后，就向服务器发送一个ACK包，
然后处于ESTABLISHED状态，服务器收到客户端发送的ACK包后也处于ESTABLISHED状态，此时客户端就可以发送数据给服务器了。
通过这样的方式可以让客户端和服务器端都知道对方是可以发送和接受数据的。

# IP协议
TCP层所进行的操作都需要委托IP层将数据封装为网络包并传输给通信对象。IP协议中必然是有源IP地址和目的IP地址的，还有协议号，因为
HTTP协议是基于TCP协议，所以协议号就是TCP协议（06）。如果一台机器有多个网卡，那怎样确定源IP地址呢？就需要将目标IP地址和网卡
的子网掩码作与操作，如果结果和Destination的IP地址相同，那就确定是这个网卡了。如果所有的网卡都匹配不上的话会最终匹配到默认网关（0.0.0.0）。
这个的子网掩码和Destination都是括号中的值，网关IP就是gateway的值。然后就可以将网络包发送到网关了。

# 两点传输 MAC
在网络层下，还会在IP协议上再添加一个MAC头部。包含了源MAC地址、目的MAC地址、协议类型（0x0800，表示IP协议）发送方的MAC地址容易得到
是在生产时写在网卡的ROM中的，那接收方的MAC地址应该从何而知呢。这是就需要ARP协议了，通过IP地址知道要发送的数据是到某个子网中，通过
广播的形式去询问这个IP的主机的MAC地址是什么，是这个IP的主机就会回答的自己的MAC地址，这样就可以放入目的MAC地址中了。但是想一想每次
这样询问MAC地址浪费的资源和时间真的有点多了，特别对于我这种有强迫症的人来说，这样的设计也令人难受。其实这里是有MAC缓存的，在得到了MAC
地址后，OS会将该IP地址和对应的MAC地址缓存起来，下次再遇到这个IP地址的时候，缓存中有的话直接从缓存中取出对应的MAC地址，不用再向网关发送
请求了。不存在的话再进行ARP请求。这样的设计合理太多了，在SpringBoot的项目中也常常用到这种思想。

# 网卡
通过上面各层的努力，终于到达了出口了。数据包在内存中是以0、1的形式存在的，要发送的话是需要先将其转换为二进制数据（电信号），然后再发送。
这些操作是需要网卡来操作的，而要控制网卡是需要网卡驱动程序的。在网卡驱动获取到数据包后，会将其放入到网卡的缓存区中，然后会在包头加上报头
和起始帧分界符，在包尾加上帧校验帧序列（FCS 用于检测数据包是否损坏）。最后网卡将其转换为电信号并发送给网线。

# 交换机




