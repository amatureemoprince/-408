# 浏览器中输入网址后到点击回车后其中发生的事情

首先浏览器做的事情就是解析这个url网址，采用的协议名称、服务器名称、端口号、访问资源在主机的具体位置 （可以为空，
这样服务器会默认index.html或default.html）。解析后会生成请求消息，包括请求方法（Get、Post等）、ip、
版本和携带的数据，但是url里放入的是域名，所以需要DNS的帮助，这个可以根据 域名去查询对应的ip地址，具体的实现方法也十分
的简单：先查看浏览器自己有没有这个url的缓存，没有的话就去问OS有没有，还没有的话还要再去host文件里看 看有没有缓存。
这样的设计可以让我们避免每次访问url都去询问DNS服务器，提高 效率。那如果上述的地方都没有域名对应的ip怎么办呢，这就需要
DNS服务器了，用户的Socket库中的方法向电脑中配置的DNS服务器发送请求：问DNS服务器有没 有这个域名的ip，有的话就直接返回给
你的电脑了，没有的话就要向根DNS服务器 （. 就是这个，一个小点点），根DNS服务器会告诉你去哪里问可以得到结果，就是顶级DNS
服务器，于是你的电脑又发个请求给顶级DNS服务器，然后顶级服务器 又会告诉你到对应的权威DNS服务器中去找，于是你的电脑又发送
一个请求到权威DNS服务器，这下终于找到了，权威DNS服务器告诉你域名对应的ip。

# 协议栈
这下准备工作终于做完了。然后浏览器就会委托OS发送数据，调用Socket库去使用协议栈进行数据的处理 和发送。协议栈有两部分：
上部分是接受浏览器传过来的数据（TCP、UDP），下部分是进行数据的发送（IP）。经过协议栈后让网卡驱动程序加上mac帧就可以通过
网卡发送到以太网中了。在数据的发送（IP）中有两个协议：ARP协议和ICMP协议，前者已经说过了，后者是告知数据包在传输过程中的
错误和控制信息的。

# TCP协议
HTTP是基于TCP协议的协议，那我们先来看看TCP是怎么回事吧。不外乎就是在要发送的数据前面加上了TCP头，那这个头里具体有什么呢？
首先是源端口号和目标端口号，需要知道是那两个应用要进行数据交互吧。还有序号，这个是防止包乱序的情况发生，还有确认号，这是判
断数据包是不是被接受了的，没有正确地接受就可以进行重传，防止了包丢失的问题，还有一些状态位如SYN、ACK、RST、FIN，TCP是面
向连接的，发送的状态位发生变化会导致连接状态发生变化。还有个重要的概念就是滑动窗口，控制流量的，不要在一段时间内发送的数据
太多了，也不要太少了。还可以进行拥塞控制。在使用HTTP发送数据前会先进行TCP的三次握手，确保双方都能进行正确的数据传输。
**具体的过程是：**
开始的时候服务器端和客户端都是处理关闭（close）状态的，然后需要服务器监听一个端口等待着客户端（此时服务器处于listen状态）
在服务器监听的时候客户端发起连接请求SYN就处于SYN_SEND状态了，服务器收到这个请求后，就向客户端发送一个SYN包和一个ACK包
此时服务器处于SYN_RECV状态，前者用于确认连接，后者用于确认服务器收到请求。然后客户端收到这个包后，就向服务器发送一个ACK包，
然后处于ESTABLISHED状态，服务器收到客户端发送的ACK包后也处于ESTABLISHED状态，此时客户端就可以发送数据给服务器了。
通过这样的方式可以让客户端和服务器端都知道对方是可以发送和接受数据的。

# IP协议
TCP层所进行的操作都需要委托IP层将数据封装为网络包并传输给通信对象。IP协议中必然是有源IP地址和目的IP地址的，还有协议号，因为
HTTP协议是基于TCP协议，所以协议号就是TCP协议（06）。如果一台机器有多个网卡，那怎样确定源IP地址呢？就需要将目标IP地址和网卡
的子网掩码作与操作，如果结果和Destination的IP地址相同，那就确定是这个网卡了。如果所有的网卡都匹配不上的话会最终匹配到默认网关（0.0.0.0）。
这个的子网掩码和Destination都是括号中的值，网关IP就是gateway的值。然后就可以将网络包发送到网关了。
·
# 两点传输 MAC
在网络层下，还会在IP协议上再添加一个MAC头部。包含了源MAC地址、目的MAC地址、协议类型（0x0800，表示IP协议）发送方的MAC地址容易得到
是在生产时写在网卡的ROM中的，那接收方的MAC地址应该从何而知呢。这是就需要ARP协议了，通过IP地址知道要发送的数据是到某个子网中，通过
广播的形式去询问这个IP的主机的MAC地址是什么，是这个IP的主机就会回答的自己的MAC地址，这样就可以放入目的MAC地址中了。但是想一想每次
这样询问MAC地址浪费的资源和时间真的有点多了，特别对于我这种有强迫症的人来说，这样的设计也令人难受。其实这里是有MAC缓存的，在得到了MAC
地址后，OS会将该IP地址和对应的MAC地址缓存起来，下次再遇到这个IP地址的时候，缓存中有的话直接从缓存中取出对应的MAC地址，不用再向网关发送
请求了。不存在的话再进行ARP请求。这样的设计合理太多了，在SpringBoot的项目中也常常用到这种思想。

# 网卡
通过上面各层的努力，终于到达了出口了。数据包在内存中是以0、1的形式存在的，要发送的话是需要先将其转换为二进制数据（电信号），然后再发送。
这些操作是需要网卡来操作的，而要控制网卡是需要网卡驱动程序的。在网卡驱动获取到数据包后，会将其放入到网卡的缓存区中，然后会在包头加上报头
和起始帧分界符，在包尾加上帧校验帧序列（FCS 用于检测数据包是否损坏）。最后网卡将其转换为电信号并发送给网线。

# 交换机
数据包通过网卡的发送会来到交换机这里，交换机的设计是为了将网络包原样转发到目的地。因为交换机工作在MAC层，因此又称其为二层网络设备。
那交换机具体是怎样工作的呢？首先，电信号到达了网线接口，交换机里的模块进行接受，然后交换机会将电信号转换为数字信号，这样才能识别信息呀。
再根据FCS校验，看看包在传输过程中有没有问题，没有的话就将其放入到缓冲区里。注意交换机是不会核对MAC地址的，所以不管是不是需要交换机接受的
只要到了这里就跑不了了，统统接收。由此可知，交换机的端口是没有MAC地址的。
将包放入到缓存区中后，就需要检查需要发送的目的MAC地址是不是已经存在MAC地址表中，交换机的MAC地址表主要是设备的MAC地址和端口（发送数据）。
如果在MAC地址表中找不到的话，交换机就会将数据发往除了源端口之外的所有端口，在目标设备做出响应后就将其存到MAC地址表中。除了这种情况外，如果
接收方的MAC地址是一个广播地址的话，也会这样发送包。（MAC：FF:FF:FF:FF:FF:FF，IP：255.255.255.255）

# 路由器
数据包表示终于到了边境了。在经过交换机发送后到达了路由器，并在这里将其转发到下一个路由器或者设备。这个地方和交换机是相似的，也是通过查表进行
转发的，只不过在具体实现的操作中存在区别。
因为路由器是基于IP设计的，故又称为三层网络设备，路由器的各个端口都具有MAC地址和IP地址。而交换机是基于以太网设计的，故又称为二层网络设备并且
交换机的端口是不具备MAC地址的。因为路由器具有MAC地址，所以它可以成为以太网的发送方和接受方；同时具备IP地址，从这里来看挺像网卡呢。
**当转发包时**：路由器会先接受发给自己的以太网包，然后通过路由表进行查询转发目标，再由相应的端口作为发送端口将以太网包发送出去。
**当接受包时**：首先电信号到达网线接口，路由器中的模块会将电信号转换为数字信号，然后根据FCS进行校验，如果没有错误就检查MAC头部中的目表MAC地址
，确认是不是自己应该接受的包，是的话就将其放入到缓冲区中，否则就就丢弃这个包。在完成包的接受操作后，路由器就会去掉包开头的MAC头部（因为之前携带
MAC地址的作用就是为了找到这个路由器），路由器会根据包携带的IP进行包的转发操作，这个跟交换机的实现有点像：使用目标IP和路由器中的子网掩码做与运算
得到的结构和Destination作比较如果相等就可以将其作为转发目标，如果是在是找不到会有个默认路由。
OK，现在找到了可以发送的目标了，进行发送阶段。首先我们需要根据路由表的网关列判断对方的地址，如果网关是一个IP地址，则这个IP地址就是我们需要转发的
目标地址，仍没有到达终点还需要进行转发。如果网关为空，则说明IP头部中的接受方IP地址就是要转发的目标地址，也就是最终点。




